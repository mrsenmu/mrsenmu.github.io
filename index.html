<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Mr.森木</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Mr.森木">
<meta property="og:url" content="http://mrsenmu.com/index.html">
<meta property="og:site_name" content="Mr.森木">
<meta property="og:description" content="description">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="senmu">
<meta property="article:tag" content="subtitle1,subtitle2,subtitle3">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Mr.森木" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Mr.森木</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">subtitle1|subtitle2|subtitle3</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://mrsenmu.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-我的测试文章" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/20211227153303.html" class="article-date">
  <time class="dt-published" datetime="2021-12-27T07:33:03.000Z" itemprop="datePublished">2021-12-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/categories/">categories</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/20211227153303.html">我的测试文章</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="一、Spring概念"><a href="#一、Spring概念" class="headerlink" title="一、Spring概念"></a>一、Spring概念</h1><ol>
<li>Spring是轻量级的开源的JavaEE框架。</li>
<li>Spring可以解决企业应用开发的复杂性。</li>
<li>Spring有两个核心部分，IOC和Aop:<ul>
<li>IOC:控制反转，把创建对象过程交给Spring进行管理。</li>
<li>Aop:面向切面编程，不修改源代码进行功能增强。</li>
</ul>
</li>
<li><strong>Spring特点</strong>（使用Spring的好处）<ul>
<li><strong>轻量</strong>:Spring 是轻量的，基本的版本大约2MB</li>
<li><strong>控制反转</strong>：Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。方便解耦，简化开发。</li>
<li>**面向切面的编程(AOP)**：Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。</li>
<li><strong>容器</strong>：Spring 包含并管理应用中对象的生命周期和配置。</li>
<li><strong>MVC框架</strong>:Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。</li>
<li><strong>方便事务管理</strong>：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）</li>
<li><strong>异常处理</strong>：Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛出的）转化为一致的unchecked 异常。</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zwwhnly/p/10448434.html">入门案例</a></li>
</ol>
<h1 id="二、IOC容器"><a href="#二、IOC容器" class="headerlink" title="二、IOC容器"></a>二、IOC容器</h1><h2 id="1、IOC底层原理"><a href="#1、IOC底层原理" class="headerlink" title="1、IOC底层原理"></a>1、IOC底层原理</h2><h3 id="Ⅰ-什么是IOC"><a href="#Ⅰ-什么是IOC" class="headerlink" title="Ⅰ 什么是IOC"></a>Ⅰ 什么是IOC</h3><ol>
<li>控制反转（Inversion of Control，缩写为<strong>IoC</strong>），把对象创建和对象之间的调用过程交给Spring进行管理。<strong>Spring 框架的核心是 Spring 容器。容器创建对象，将它们装配在一起，配置它们并管理它们的完整生命周期。</strong>Spring 容器使用<strong>依赖注入</strong>来管理组成应用程序的组件。容器通过读取提供的配置元数据来接收对象进行实例化，配置和组装的指令。该元数据可以通过 XML，Java 注解或 Java 代码提供。</li>
<li>使用目的：为了降低耦合度。</li>
<li>涉及技术：xml解析、工厂模式、反射。</li>
</ol>
<h2 id="2、IOC接口（BeanFactory）"><a href="#2、IOC接口（BeanFactory）" class="headerlink" title="2、IOC接口（BeanFactory）"></a>2、IOC接口（BeanFactory）</h2><ol>
<li><p>IOC思想基于IOC容器完成，IOC容器底层就是对象工厂。</p>
</li>
<li><p>Spring提供IOC容器实现两种方式：（两个接口）</p>
<ul>
<li>BeanFactory:<ul>
<li>IOC容器基本实现，是Spring内部的使用接口，不提供开发人员进行使用。</li>
<li>加载配置文件时不会创建对象，在获取对象（使用）时采取创建对象。</li>
</ul>
</li>
<li>ApplicationContext:<ul>
<li>BeanFactory接口的子接口，提供更多更强大的功能，一般由开发人员进行使用。</li>
<li>加载配置文件时就把配置文件对象进行创建。</li>
</ul>
</li>
</ul>
</li>
<li><p>ApplicationContext两个重要实现类：</p>
<ul>
<li>FileSystemXmlApplicationContext：路径包含盘符的全路径。</li>
<li>ClassPathXmlApplicationContext：src目录下。</li>
</ul>
</li>
</ol>
<h2 id="3、IOC操作Bean管理（基于XML）"><a href="#3、IOC操作Bean管理（基于XML）" class="headerlink" title="3、IOC操作Bean管理（基于XML）"></a>3、IOC操作Bean管理（基于XML）</h2><h3 id="Ⅰ-什么是Bean管理"><a href="#Ⅰ-什么是Bean管理" class="headerlink" title="Ⅰ 什么是Bean管理"></a>Ⅰ 什么是Bean管理</h3><ol>
<li>Spring创建对象。</li>
<li>Spring注入属性。</li>
</ol>
<h3 id="Ⅱ-Bean管理操作有两个操作"><a href="#Ⅱ-Bean管理操作有两个操作" class="headerlink" title="Ⅱ Bean管理操作有两个操作"></a>Ⅱ Bean管理操作有两个操作</h3><ol>
<li>基于xml配置文件方式实现。</li>
<li>基于注解方式实现。</li>
</ol>
<h3 id="Ⅲ-基于xml"><a href="#Ⅲ-基于xml" class="headerlink" title="Ⅲ 基于xml"></a>Ⅲ 基于xml</h3><ol>
<li><p><strong>创建对象</strong></p>
<ul>
<li><p>在spring配置文件中，使用<strong>bean标签</strong>，标签里添加对应属性，就可以实现对象创建。</p>
</li>
<li><p>bean标签中的常用属性：</p>
<ul>
<li><p>id：唯一标识。</p>
</li>
<li><p>class：类全路径（包、类路径）。</p>
</li>
<li><p>name：标识名称。</p>
</li>
<li><p>ref：可用于注入外部bean（类为成员变量时）。</p>
</li>
</ul>
</li>
<li><p><strong>创建对象时候，默认也是执行无参构造器。</strong></p>
</li>
</ul>
</li>
<li><p><strong>注入属性</strong></p>
<ul>
<li>DI：依赖注入，就是注入属性。通常可通过构造器、setter、接口实现。</li>
<li>spring框架中，<strong>仅使用有参构造器和 setter 注入</strong>。</li>
<li>注入属性两种常用方法，xml配置文件中，在<bean>标签中：<ul>
<li><property>标签<strong>，创建对象时，直接配置对应类的属性值，name=属性名称，value=注入值。</strong></li>
<li><constructor-arg>标签<strong>，配置对应类的有参构造器配置。</strong></li>
</ul>
</li>
<li>注入特殊类型属性：<ul>
<li><strong>注入外部bean：标签中使用 ref</strong> 属性通过外部bean的<strong>id</strong>引入。常用于类中包含其他类类型的属性时。</li>
<li>内部bean：使用情况与外部bean注入相同，使用方法是直接在属性**<property>标签**中嵌套bean标签。不常用，因为通过引用的方式，写在外层的bean，可复用。</li>
<li>级联赋值：就是bean标签中<strong>调用</strong>其他bean，且<strong>对其属性赋值</strong>。</li>
<li>注入集合属性：由于有多项数据，不能直接value赋值。<ul>
<li>对于<strong>数组等</strong>单列数据，可用<list>或<array>标签包裹多个<value></li>
<li>对于<strong>set</strong>，<set><value>…</value>…</set></li>
<li>对于<strong>map</strong>等双列数据，<map><entry key=" " value=" "></entry>…</map></li>
<li>可以&lt;util:list id=”bookList”&gt;<value>…</util>等的方式配置一个全局集合，可重复引用。</li>
</ul>
</li>
</ul>
</li>
<li>当value值中包含特殊符号（如&lt;&gt;）：<ul>
<li>用转义字符如&amp;lt，标签语言可查。</li>
<li>数据写进CDATA中：PCDATA 指的是<strong>被解析的字符数据</strong>。 CDATA 指的是<strong>不应由 XML 解析器进行解析的文本数据</strong>。CDATA 部分如 **<![CDATA[** 包含转义字符<>,不应被解析的文本数据 **]]>**。</li>
</ul>
</li>
</ul>
</li>
<li><p>工厂bean</p>
<ul>
<li>spring中有两种bean，一种是普通的，一种是工厂bean（FactoryBean）</li>
<li>两种bean区别：<ul>
<li>普通bean：在xml配置文件中定义bean类型就是返回类型。</li>
<li>工厂bean：定义类型和返回类型可以不一样。</li>
</ul>
</li>
<li>工厂bean的使用：<ul>
<li>创建<strong>FactoryBean接口</strong>的<strong>实现类，</strong>作为工厂bean。</li>
<li>实现三个方法，getObject(), getObjectType(), isSingleton()。返回类型由重写的方法 getObject() 中定义。</li>
</ul>
</li>
</ul>
</li>
<li><p>bean的作用域（设置单例、多例）</p>
<ul>
<li>默认bean为单实例对象，在类中创建，赋值多个对象，对象<strong>地址</strong>也一样。</li>
<li>scope属性值：<ul>
<li>默认singleton：单例。加载配置文件时就会创建单例对象。</li>
<li>prototype：多实例对象。调用getBean()方法时创建对象。</li>
<li>request：放在请求域中。</li>
<li>session：放在会话域中。</li>
</ul>
</li>
</ul>
</li>
<li><p>bean的<strong>生命周期</strong></p>
<ul>
<li>加载配置文件：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context</span><br><span class="line"><span class="keyword">new</span> ClassPathXmlApplicationContext bean4.xml;</span><br><span class="line">ClassPathXmlApplicationContext context =</span><br><span class="line"><span class="keyword">new</span> ClassPathXmlApplicationContext (<span class="string">&quot;bean4.xml&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>执行无参构造器创造实例。</p>
</li>
<li><p>设置bean的属性值和其他bean的引用（调用setter）。</p>
</li>
<li><p><strong>将bean实例传递给bean后置处理器的</strong>postProcess<strong>Before</strong>Initialization() <strong>方法。（加后置处理器时，在调用初始化步骤前后）</strong></p>
</li>
<li><p><strong>自动调用</strong>bean的<strong>初始化方法</strong>（需要在bean标签中配置<strong>init-method=”initMethod()”属性</strong>和在类中定义初始化initMethod()方法）</p>
</li>
<li><p><strong>将bean实例传递给bean后置处理器的</strong>postProcess<strong>After</strong>Initialization() <strong>方法。（加后置处理器时）</strong></p>
</li>
<li><p>使用bean，通过调用 context.getBean() 方法时获取对象。</p>
</li>
<li><p>当容器关闭时，((ClassPathxmlApplicationContext) context).close ()；<strong>手动调用</strong>bean的销毁的方法（需要在bean标签中配置<strong>destroy-method=”destroyMethod()”属性</strong>和在类中定义**destroyMethod()**销毁方法）.</p>
</li>
</ul>
</li>
<li><p>后置处理器</p>
<ul>
<li>若存在，则在执行时期在生命周期中调用初始化方法的前后。</li>
<li>创建实现类实现BeanPostProcessor接口中的postProcess<strong>Before</strong>Initialization（Object bean，String beanName）和 postProcess<strong>After</strong>Initialization（Object bean，String beanName）方法。</li>
<li>xml中配置：与配置普通的bean相同。</li>
</ul>
</li>
<li><p>xml的自动装配</p>
<ul>
<li>根据指定装配规则（属性名或属性类型），Spring自动将匹配的属性值进行注入。</li>
<li>自动装配的过程：<bean>标签中属性autowire=”…”。可设值：byName：根据名称自动装配。byType：根据属性类型自动注入。</li>
<li>不常用，一般通过注解自动装配。</li>
</ul>
</li>
<li><p>外部属性文件（常用于配置连接池）</p>
<ul>
<li>直接配置：与配置bean类似，将驱动器、url、username、password通过<property>设置value属性值。</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41865229/article/details/120758434">外部引用</a>：第一步:引入context命名空间。第二步:引入外部属性文件。第三步:引用外部属性文件中的属性值。</li>
</ul>
</li>
</ol>
<h2 id="4、IOC操作Bean管理（基于注解）"><a href="#4、IOC操作Bean管理（基于注解）" class="headerlink" title="4、IOC操作Bean管理（基于注解）"></a>4、IOC操作Bean管理（基于注解）</h2><h3 id="Ⅰ-什么是注解"><a href="#Ⅰ-什么是注解" class="headerlink" title="Ⅰ 什么是注解"></a>Ⅰ 什么是注解</h3><ol>
<li>注解是代码的特殊标记，格式：@注解名称(属性名=属性值，…)</li>
<li>使用注解，定义在类、方法、属性上。</li>
<li>目的：简化xml配置。</li>
</ol>
<h3 id="Ⅱ-Spring针对Bean管理中的创建对象提供注解"><a href="#Ⅱ-Spring针对Bean管理中的创建对象提供注解" class="headerlink" title="Ⅱ Spring针对Bean管理中的创建对象提供注解"></a>Ⅱ Spring针对Bean管理中的创建对象提供注解</h3><ol>
<li>@<strong>Controller</strong> 控制器（注入服务）用于标注控制层，相当于struts中的action层。</li>
<li>@<strong>Service</strong> 服务（注入dao）用于标注服务层，主要用来进行业务的逻辑处理。</li>
<li>@<strong>Rrepository</strong>（实现dao访问）用于标注数据访问层，也可以说用于标注数据访问组件，即DAO组件</li>
<li>@<strong>Component</strong> （把普通pojo实例化到spring容器中，相当于配置文件中的)泛指各种组件，就是说当我们的类不属于各种归类的时候（不属于@Controller、@Services等的时候），我们就可以使用@Component来标注这个类。</li>
<li>前四个注解<strong>都可以用来创建bean实例</strong>。</li>
</ol>
<h3 id="Ⅲ-基于注解方式实现对象创建"><a href="#Ⅲ-基于注解方式实现对象创建" class="headerlink" title="Ⅲ 基于注解方式实现对象创建"></a>Ⅲ 基于注解方式实现对象创建</h3><ol>
<li>第一步：引入依赖（spring-aop-5.2.9.RELEASE.jar）。</li>
<li>第二部：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43883917/article/details/112747184">开启组件扫描</a>。先引入context命名空间。再配置扫描范围（&lt;context:component-scan base-package=”包名”&gt; … </context:component-scan>）。<strong>默认的情况就是都扫描,可配置扫描的文件列表和不扫描的文件列表</strong>。</li>
<li>第三步：使用注解修饰代码结构。</li>
</ol>
<h3 id="Ⅳ-基于注解方法实现属性注入"><a href="#Ⅳ-基于注解方法实现属性注入" class="headerlink" title="Ⅳ 基于注解方法实现属性注入"></a>Ⅳ 基于注解方法实现属性注入</h3><ol>
<li>@<strong>Autowired：</strong>自动根据类型注入，自动装配常用注解。</li>
<li>@<strong>Qualifier(value=”名称”)<strong>：指定自动注入的id名称，</strong>与上个注解一起使用</strong>，适用于接口有多个实现类时，指定具体实现类id。</li>
<li>@Resource(“名称”)：默认无属性根据类型注入，加属性name=”类id”，可根据名称注入。区别，非spring框架包中的，而是javax中的。</li>
<li>@Value(value=…)：注入普通类型属性，注入实际值。使用：直接在类属性上修饰。使用后就不用在xml中配置注入了。</li>
</ol>
<h3 id="Ⅴ-完全注解开发"><a href="#Ⅴ-完全注解开发" class="headerlink" title="Ⅴ 完全注解开发"></a>Ⅴ 完全注解开发</h3><ol>
<li><p>创建配置类，替代xml文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span><span class="comment">//作为配置类，替代xml配置文件</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages com.atguigu &#125;</span></span><br><span class="line"><span class="meta">public class SpringConfig</span></span><br></pre></td></tr></table></figure></li>
<li><p>编写测试类：加载配置时，获取的是AnnotationConfigApplicationContext(配置类.class)实例，且不是加载xml文件。</p>
</li>
</ol>
<h1 id="三、AOP（面向切面编程）"><a href="#三、AOP（面向切面编程）" class="headerlink" title="三、AOP（面向切面编程）"></a>三、AOP（面向切面编程）</h1><h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><ul>
<li>面向切面编程，利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的<strong>耦合度降低</strong>，提高程序的可复用性，同时提高了开发的效率。</li>
<li>简介的说：<strong>AOP允许不通过修改源代码方式，在主干功能里添加新功能。</strong></li>
<li>举例（登录功能）：<ul>
<li>常规基本流程：输入用户名密码 -&gt; 数据库查询 -&gt; 验证 – 成功 –&gt;主页面（否则回到登陆页面）</li>
<li>若需要添加权限判断功能，原始方式需要修改源代码。而AOP可不通过修改源代码方式添加新的功能（添加秦安判断模块，配置进去）</li>
</ul>
</li>
</ul>
<h2 id="2、AOP的底层原理"><a href="#2、AOP的底层原理" class="headerlink" title="2、AOP的底层原理"></a>2、AOP的底层原理</h2><h3 id="Ⅰ-AOP底层使用动态代理"><a href="#Ⅰ-AOP底层使用动态代理" class="headerlink" title="Ⅰ AOP底层使用动态代理"></a>Ⅰ AOP底层使用动态代理</h3><ol>
<li>有两种情况的动态代理：<ul>
<li><strong>有接口</strong>情况，使用JDK动态代理，创建被代理类共同接口实现类的代理类。</li>
<li><strong>没有接口</strong>情况，使用CGLIB动态代理：创建继承 被代理类 的父类的代理类。</li>
<li>CGLIB（Code Genneration Library）是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充。通常可以使用Java的动态代理创建代理，但当要代理的类没有实现接口或者为了更好的性能，CGLIB是一个好的选择。</li>
</ul>
</li>
</ol>
<h2 id="3、JDK动态代理"><a href="#3、JDK动态代理" class="headerlink" title="3、JDK动态代理"></a>3、JDK动态代理</h2><ol>
<li><p>使用JDK动态代理，使用java.lang.reflect.Proxy类里面的方法创建代理对象。</p>
<ul>
<li><p>调用newProxyInstance方法</p>
</li>
<li><table>
<thead>
<tr>
<th>static object</th>
<th align="left">newProxyInstance(ClassLoader loader,类&lt;？&gt;[]interfaces，InvocationHandler h)</th>
<th>返回指定接口的代理实例，该接口将方法调用分派给指定的调用处理程序。</th>
</tr>
</thead>
</table>
</li>
<li><p>参数一：类加载器</p>
</li>
<li><p>参数二：增强方法所爱类，这个类实现的接口，支持多个接口。</p>
</li>
<li><p>参数三： 实现这个接口Invocationhander，创建代理对象，写增强的方法。可用匿名实现类方式，也可单独写个实现类实现Invocationhandler接口。</p>
</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/269afd0a52e6">编写动态代理代码</a>。</p>
<ul>
<li>属性：被代理类对象和返回被代理类的方法。</li>
<li>实现invoke方法：public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {}</li>
</ul>
</li>
</ol>
<h2 id="4、AOP术语"><a href="#4、AOP术语" class="headerlink" title="4、AOP术语"></a>4、AOP术语</h2><ol>
<li>连接点：类里面那些方法<strong>可以被增强</strong>，这些方法称为连接点。</li>
<li>切入点：<strong>实际被真正增强</strong>的方法，称为切入点。</li>
<li>通知（增强）：<ul>
<li>实际增强的逻辑部分曾为通知（增强）。</li>
<li>通知有多种类型：<ul>
<li>前置通知：被增强方法之前执行。</li>
<li>后置通知：之后执行。</li>
<li>环绕通知：前后都执行。</li>
<li>异常通知：出现异常时执行。</li>
<li>最终通知：类似finally，无论有无异常，都会执行。</li>
</ul>
</li>
</ul>
</li>
<li>切面：是动作过程，把通知应用到切入点的过程。</li>
</ol>
<h2 id="5、-AOP操作（准备）"><a href="#5、-AOP操作（准备）" class="headerlink" title="5、 AOP操作（准备）"></a>5、 AOP操作（准备）</h2><h3 id="Ⅰ什么是AspectJ"><a href="#Ⅰ什么是AspectJ" class="headerlink" title="Ⅰ什么是AspectJ"></a>Ⅰ什么是AspectJ</h3><ol>
<li>Spring框架一般都是基于AspectJ实现AOP操作。</li>
<li>AspectJ不是Spring组成部分，独立AOP框架，一般AspectJ和Spring框架一起使用，进行AOP操作。</li>
</ol>
<h3 id="Ⅱ-基于AspectJ实现AOP操作"><a href="#Ⅱ-基于AspectJ实现AOP操作" class="headerlink" title="Ⅱ 基于AspectJ实现AOP操作"></a>Ⅱ 基于AspectJ实现AOP操作</h3><ol>
<li><p>基于<strong>xml配置</strong>文件实现：</p>
<ul>
<li><p>创建两个类，增强类和被增强类，创建方法。</p>
</li>
<li><p>在spring配置文件中创建两个类对象。</p>
</li>
<li><p>在spring配置文件中配置AOP增强，利用<a href="aop:config">aop:config</a>:</p>
</li>
<li><pre><code class="xml">&lt;!--配置aop增强--&gt;
&lt;aop:config&gt;
    &lt;!--切入点--&gt;
    &lt;aop:pointcut id=&quot;p&quot;expression=&quot;execution(*com.atguigu.spring5.aopxml.Book.buy(..))&quot;/&gt;
    &lt;!--配置切面--&gt;
    &lt;aop:aspect ref=&quot;bookProxy&quot;&gt;
        &lt;!--增强作用在具体的方法上--&gt;
        &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;p&quot;/&gt;
    &lt;/aop:aspect&gt;
&lt;/aop:config&gt;
</code></pre>
</li>
</ul>
</li>
<li><p>基于<strong>注解方式</strong>实现（使用）：</p>
<ul>
<li>创建被增强类类，在类里定义方法。</li>
<li>创建增强类（编写增强逻辑）在增强类里，创建方法，让不同方法代表不同通知类型，如before()代表前置通知。</li>
<li>进行配置通知<ul>
<li>在spring配置文件中，开启注解扫描。</li>
<li>使用注解创建被代理类和代理类对象(如@Comment)。</li>
<li>在增强类上面注解@Aspect。</li>
<li>在spring配置文件中开启生成代理对象（标签：<a href="aop:aspectj-autoproxy">aop:aspectj-autoproxy</a>&lt;/aop……&gt;）。</li>
</ul>
</li>
<li>配置<strong>不同类型的通知</strong><ul>
<li>在增强类的里面，在作为通知方法上面添加通知类型注解，使用切入点表达式配置。</li>
<li>如配置前置通：@Before(value=”execution(<em>com.senmu.dao.BookDao.add(..))”)</em></li>
<li><strong>通知注解类型</strong>：@<strong>After</strong>：不管有无异常都执行，可称为<strong>最终通知</strong>；@Around：环绕；@AfterThrowing：异常；@<strong>AfterReturning</strong>：返回值之后执行，可称为<strong>后置通知，一般在After之后执行</strong>。</li>
<li><strong>相同切入点抽取</strong>：可用@pointcut(value=”excution(通用部分)”) 注解 切入点抽取方法（如pointCut()），返回注解中相同的切入点表达式。则通知注解就可写成@Before(value=”pointCut()”)</li>
<li>若有多个增强类增强同一个方法，可<strong>设置优先级</strong>。@Order（数字型值），越小优先级越高。</li>
<li><strong>可实现完全注解开发，可在配置类中配置AspectJ。</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>在项目工程里引入依赖</p>
</li>
<li><p>切入点表达式：</p>
<ul>
<li>切入点表达式作用：知道对哪个类里面的哪个方法进行增强。</li>
<li>语法结构：<ul>
<li>execution([权限修饰符] [返回类型] [类全路径] [方法名称] [参数列表])</li>
<li>案例：对com.senmu.dao.BookDao类里的add()进行增强：execution(*com.senmu.dao.BookDao.add(..))</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="四、JdbcTemplate"><a href="#四、JdbcTemplate" class="headerlink" title="四、JdbcTemplate"></a>四、JdbcTemplate</h1><h2 id="1、什么是JdbcTeamplate"><a href="#1、什么是JdbcTeamplate" class="headerlink" title="1、什么是JdbcTeamplate"></a>1、什么是JdbcTeamplate</h2><ol>
<li>Spring框架对JDBC进行封装，使用JdbcTempate方便实现对数据库操作。</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/caoyc/p/5630622.html">准备工作</a><ul>
<li>引入相关jar包</li>
<li>在Spring配置文件<strong>配置数据库连接池</strong></li>
<li>配置JdbcTemlate对象，注入DataSource。</li>
<li>创建service类，注入dao，创建dao类，在dao中注入JdbcTeamplate。</li>
</ul>
</li>
</ol>
<h2 id="2、JdbcTemplate操作数据库"><a href="#2、JdbcTemplate操作数据库" class="headerlink" title="2、JdbcTemplate操作数据库"></a>2、JdbcTemplate操作数据库</h2><ol>
<li> 对应数据库创建实体类（entity）:放在entity下的beans。</li>
<li> 编写service和dao:在dao中进行数据库操作。</li>
</ol>
<h1 id="五、事物管理"><a href="#五、事物管理" class="headerlink" title="五、事物管理"></a>五、事物管理</h1><h1 id="六、Spring5新特性"><a href="#六、Spring5新特性" class="headerlink" title="六、Spring5新特性"></a>六、Spring5新特性</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://mrsenmu.com/post/20211227153303.html" data-id="ckxof9mkf0001t4t26dtu4p9j" data-title="我的测试文章" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tag1-tag2/" rel="tag">-tag1 -tag2</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/post/20211221114453.html" class="article-date">
  <time class="dt-published" datetime="2021-12-21T03:44:53.856Z" itemprop="datePublished">2021-12-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/post/20211221114453.html">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://mrsenmu.com/post/20211221114453.html" data-id="ckxof9mkb0000t4t2d0l02sqi" data-title="Hello World" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/categories/">categories</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/tag1-tag2/" rel="tag">-tag1 -tag2</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/tag1-tag2/" style="font-size: 10px;">-tag1 -tag2</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">十二月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/post/20211227153303.html">我的测试文章</a>
          </li>
        
          <li>
            <a href="/post/20211221114453.html">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 senmu<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>